// Generated by CoffeeScript 1.9.2

/*
Maintain a cache of queries to reduce re-querying.
 */
var async, diff, optimise, parallelqueries;

async = require('odo-async');

diff = require('./diff');

optimise = require('./optimise');

parallelqueries = require('./parallelqueries');

module.exports = function(exe, options) {
  var _cached, _e, log, pq, res;
  log = function() {};
  if ((options != null ? options.hub : void 0) != null) {
    log = function(message) {
      return options.hub.emit('[odoql-exe] {message}', {
        message: message
      });
    };
  }
  if (options == null) {
    options = {};
  }
  if (options.maxparallelqueries == null) {
    options.maxparallelqueries = 5;
  }
  _cached = {};
  _e = {
    ready: [],
    result: [],
    error: []
  };
  pq = parallelqueries(options.maxparallelqueries, function(timings) {
    var e, i, len, ref, results1;
    ref = _e.ready;
    results1 = [];
    for (i = 0, len = ref.length; i < len; i++) {
      e = ref[i];
      results1.push(e(timings));
    }
    return results1;
  });
  res = function() {};
  res.apply = function(queries) {
    var _, key, results1;
    results1 = [];
    for (key in queries) {
      _ = queries[key];
      results1.push(_cached[key] = queries[key]);
    }
    return results1;
  };
  res.run = function(queries) {
    var optimisedqueries;
    queries = diff(_cached, queries);
    if (Object.keys(_cached).length > 0) {
      log((Object.keys(_cached).join(', ')) + " in the cache");
    }
    if (Object.keys(queries).length > 0) {
      log((Object.keys(queries).join(', ')) + " new or changed");
    }
    optimisedqueries = optimise(exe, queries);
    return async.delay(function() {
      var fn, i, len, query;
      fn = function(query) {
        var callback, e, j, k, key, len1, len2, ref, ref1, update;
        if (query.isAsync) {
          update = {};
          ref = query.keys;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            key = ref[j];
            update[key] = null;
          }
          ref1 = _e.result;
          for (k = 0, len2 = ref1.length; k < len2; k++) {
            e = ref1[k];
            e(update);
          }
        }
        callback = function(cb) {
          return query.query(function(errors, results) {
            var error, l, len3, ref2;
            if (errors != null) {
              log((Object.keys(errors).join(', ')) + " errored");
              for (key in errors) {
                error = errors[key];
                log(key + ": " + error);
              }
              ref2 = _e.error;
              for (l = 0, len3 = ref2.length; l < len3; l++) {
                e = ref2[l];
                e(errors);
              }
            }
            return cb(errors, function(keys) {
              var len4, len5, m, n, ref3, results1;
              log((keys.join(', ')) + " complete, caching");
              update = {};
              for (m = 0, len4 = keys.length; m < len4; m++) {
                key = keys[m];
                _cached[key] = queries[key];
                update[key] = results[key];
              }
              ref3 = _e.result;
              results1 = [];
              for (n = 0, len5 = ref3.length; n < len5; n++) {
                e = ref3[n];
                results1.push(e(update));
              }
              return results1;
            });
          });
        };
        return pq.add(query.isAsync, query.keys, callback);
      };
      for (i = 0, len = optimisedqueries.length; i < len; i++) {
        query = optimisedqueries[i];
        fn(query);
      }
      return pq.exec();
    });
  };
  res.on = function(e, cb) {
    if (_e[e] == null) {
      _e[e] = [];
    }
    return _e[e].push(cb);
  };
  return res;
};
